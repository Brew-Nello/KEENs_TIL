# 탐욕법 (Greedy)
- 현재 상황에서 가장 좋은 것 (최선의 선택)을 고르는 알고리즘
→ 현재 최적인 답을 선택하는 과정을 반복하여 결과를 도출한다.

- 동적 프로그래밍을 간단한 문제 해결에 사용하면 지나치게 많은 일을 한다는 것에서 착안하여 고안되었다.

```
    각 단계에서 선택한 최적해가 전체적으로도 최선이길 "바라는" 알고리즘   
    (바라는거지 그게 최적해라는 것은 아님)  
```

## BUT
가장 좋은 결과는 최적해를 보장하지는 않는다. → 그래서 근삿값을 구하는 용도로 사용되곤 한다.

매 순간 최적의 해로 보이는 해를 선택하며 현재 선택이 나중에 어떤 영향을 미칠지 고려하지 않는다.

# 충족 조건
- 앞의 선택이 이후의 선택에 영향을 주지 않을 때 (= Greedy Choice Property)
- 문제의 최적해가 부분 문제에 대해서도 최적해일 때 (= Optimal Substructure)

→ 두 조건을 모두 만족한다면 최적해를 구할 수 있다. 그렇지 않으면 `근삿값` 정도 구할 수 있다.

### 근삿값을 구해서 어디에 쓰는가??
- 항상 최적의 결과를 도출하지는 않지만, 어느정도 최적에 근사한 값을 빠르게 도출할 수 있다는 장점!
- 탐욕 알고리즘은 근사 알고리즘으로 사용할 수 있다.

> 근사 알고리즘(Approximation Algorithm) 이란
- 어떤 최적화 문제에 대한 해의 근사값을 구하는 알고리즘
- 비교적 빠른 시간에 계산이 가능하며, 어느정도 보장된 근사해를 구할 수 있다.


# 어떻게 풀까
- 문제의 답을 만드는 과정을 여러 부분 문제로 나눈다.
- 각 부분 문제마다 어떠한 우선순위(조건)으로 탐욕적으로 선택할지 결정
- ‘탐욕적 선택 속성', ‘최적 부분 구조'를 만족하는지 체크

### 탐욕적 선택 속성 (Greedy Choice Property)

- 답의 모든 부분을 고려하지 않고 탐욕적으로만 선택하더라도 최적해를 구할 수 있다는 속성
- ‘항상 모든 단계에서 탐욕적으로 선택한 답이 최적해에 포함되어있다’ 라는 뜻

### 최적 부분 구조 (Optimal Substructure)

- 부분 문제의 최적해로 전체 문제의 최적해를 만들 수 있음을 말한다.
→ 항상 최적의 선택만 내렸을 때 전체 문제의 최적해를 구할 수 있는지 보아야 한다.
(이 속성은 보통 증명할 필요가 없이 저명한 경우가 많다.)


# TIP
ex. `최단 경로`, `교환 가능한 동전의 최소 갯수`, `가능한 많은 수의 회의시간`

```
예제를 풀어보는 것을 추천한다.
풀 때 손으로 & 수학문제 풀듯이 먼저 풀어보면 도움이 될 것이다.
```
